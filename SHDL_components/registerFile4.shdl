use stdgates::{AND, NOT};
use register16::{Register16};
use mux4to1_16::{Mux4to1_16};

# Register File with 4 16-bit registers
# regSel[2]: selects which register to read/write
# writeEn: enables writing to selected register
# Outputs data from selected register
component RegisterFile4(dataIn[16], regSel[2], writeEn, clk) -> (dataOut[16]) {
    
    # 4 registers
    reg0: Register16;
    reg1: Register16;
    reg2: Register16;
    reg3: Register16;
    
    # Write enable decoder
    not_sel0: NOT;
    not_sel1: NOT;
    dec0: AND;  # 00
    dec1: AND;  # 01
    dec2: AND;  # 10
    dec3: AND;  # 11
    
    # Enable gates for each register
    en0: AND;
    en1: AND;
    en2: AND;
    en3: AND;
    
    # Output multiplexer
    mux_out: Mux4to1_16;
    
    connect {
        # Decode register selection
        regSel[1] -> not_sel0.A;
        regSel[2] -> not_sel1.A;
        
        not_sel0.O -> dec0.A;
        not_sel1.O -> dec0.B;
        
        regSel[1] -> dec1.A;
        not_sel1.O -> dec1.B;
        
        not_sel0.O -> dec2.A;
        regSel[2] -> dec2.B;
        
        regSel[1] -> dec3.A;
        regSel[2] -> dec3.B;
        
        # Generate enable signals for each register
        dec0.O -> en0.A;
        writeEn -> en0.B;
        
        dec1.O -> en1.A;
        writeEn -> en1.B;
        
        dec2.O -> en2.A;
        writeEn -> en2.B;
        
        dec3.O -> en3.A;
        writeEn -> en3.B;
        
        # Connect registers
        >i[16]{
            dataIn[{i}] -> reg0.In[{i}];
            dataIn[{i}] -> reg1.In[{i}];
            dataIn[{i}] -> reg2.In[{i}];
            dataIn[{i}] -> reg3.In[{i}];
        }
        
        clk -> reg0.clk;
        clk -> reg1.clk;
        clk -> reg2.clk;
        clk -> reg3.clk;
        
        en0.O -> reg0.enable;
        en1.O -> reg1.enable;
        en2.O -> reg2.enable;
        en3.O -> reg3.enable;
        
        # Connect register outputs to multiplexer
        >i[16]{
            reg0.Out[{i}] -> mux_out.In0[{i}];
            reg1.Out[{i}] -> mux_out.In1[{i}];
            reg2.Out[{i}] -> mux_out.In2[{i}];
            reg3.Out[{i}] -> mux_out.In3[{i}];
        }
        
        regSel[1] -> mux_out.sel[1];
        regSel[2] -> mux_out.sel[2];
        
        >i[16]{
            mux_out.Out[{i}] -> dataOut[{i}];
        }
    }
}
