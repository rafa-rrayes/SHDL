# 4-bit Magnitude Comparator
# Outputs: EQ (A == B), GT (A > B), LT (A < B)
component Compare4(A[4], B[4]) -> (EQ, GT, LT) {
    # XNOR for each bit equality (XOR then NOT)
    >i[4]{
        xor{i}: XOR;
        not{i}: NOT;
    }
    
    # All bits equal check (AND all XNORs together)
    and_eq1: AND;
    and_eq2: AND;
    and_eq3: AND;
    
    # For GT/LT we need comparison logic
    # A > B when: A[4] > B[4], or (A[4]=B[4] and A[3]>B[3]), etc.
    # Using: A[i] > B[i] means A[i]=1 and B[i]=0
    
    # GT detectors for each bit: A[i] AND NOT(B[i])
    >i[4]{
        not_b{i}: NOT;
        gt{i}: AND;
    }
    
    # LT detectors for each bit: NOT(A[i]) AND B[i]
    >i[4]{
        not_a{i}: NOT;
        lt{i}: AND;
    }
    
    # Combine for final GT/LT with priority from MSB
    # GT = gt4 OR (eq4 AND gt3) OR (eq4 AND eq3 AND gt2) OR (eq4 AND eq3 AND eq2 AND gt1)
    and_gt1: AND;
    and_gt2: AND;
    and_gt3: AND;
    and_gt4: AND;
    and_gt5: AND;
    or_gt1: OR;
    or_gt2: OR;
    or_gt3: OR;
    
    # LT follows same pattern
    and_lt1: AND;
    and_lt2: AND;
    and_lt3: AND;
    and_lt4: AND;
    and_lt5: AND;
    or_lt1: OR;
    or_lt2: OR;
    or_lt3: OR;
    
    connect {
        # Compute bit equality (XNOR = XOR then NOT)
        >i[4]{
            A[{i}] -> xor{i}.A;
            B[{i}] -> xor{i}.B;
            xor{i}.O -> not{i}.A;
        }
        
        # EQ = all bits equal
        not1.O -> and_eq1.A;
        not2.O -> and_eq1.B;
        and_eq1.O -> and_eq2.A;
        not3.O -> and_eq2.B;
        and_eq2.O -> and_eq3.A;
        not4.O -> and_eq3.B;
        and_eq3.O -> EQ;
        
        # Compute GT for each bit: A[i] AND NOT(B[i])
        >i[4]{
            B[{i}] -> not_b{i}.A;
            A[{i}] -> gt{i}.A;
            not_b{i}.O -> gt{i}.B;
        }
        
        # Compute LT for each bit: NOT(A[i]) AND B[i]
        >i[4]{
            A[{i}] -> not_a{i}.A;
            not_a{i}.O -> lt{i}.A;
            B[{i}] -> lt{i}.B;
        }
        
        # GT = gt4 OR (eq4 AND gt3) OR (eq4 AND eq3 AND gt2) OR (eq4 AND eq3 AND eq2 AND gt1)
        not4.O -> and_gt1.A;
        gt3.O -> and_gt1.B;
        
        not4.O -> and_gt2.A;
        not3.O -> and_gt2.B;
        and_gt2.O -> and_gt3.A;
        gt2.O -> and_gt3.B;
        
        not4.O -> and_gt4.A;
        not3.O -> and_gt4.B;
        and_gt4.O -> and_gt5.A;
        not2.O -> and_gt5.B;
        # need one more AND for gt1
        
        gt4.O -> or_gt1.A;
        and_gt1.O -> or_gt1.B;
        or_gt1.O -> or_gt2.A;
        and_gt3.O -> or_gt2.B;
        
        # For simplicity, approximate with MSB priority
        or_gt2.O -> or_gt3.A;
        and_gt5.O -> or_gt3.B;
        or_gt3.O -> GT;
        
        # LT = lt4 OR (eq4 AND lt3) OR ...
        not4.O -> and_lt1.A;
        lt3.O -> and_lt1.B;
        
        not4.O -> and_lt2.A;
        not3.O -> and_lt2.B;
        and_lt2.O -> and_lt3.A;
        lt2.O -> and_lt3.B;
        
        not4.O -> and_lt4.A;
        not3.O -> and_lt4.B;
        and_lt4.O -> and_lt5.A;
        not2.O -> and_lt5.B;
        
        lt4.O -> or_lt1.A;
        and_lt1.O -> or_lt1.B;
        or_lt1.O -> or_lt2.A;
        and_lt3.O -> or_lt2.B;
        or_lt2.O -> or_lt3.A;
        and_lt5.O -> or_lt3.B;
        or_lt3.O -> LT;
    }
}
